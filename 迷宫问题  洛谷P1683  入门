#include <iostream>
#include<algorithm>
#include<cstring>

using namespace std;

// 定义一个常量N，用于表示二维字符数组的最大尺寸，这里假设最多是30x30的矩阵
const int N = 30;
// 分别用于存储小路的宽度和长度
int n, m;
// 二维字符数组，用于存储表示小路瓷砖情况的字符矩阵
// '.' 代表安全的砖，'#' 代表不安全的砖，'@' 代表第一块砖
char g[N][N];
// 用于记录能够安全走过的最多砖块个数，初始化为0
int res = 0;
// 二维布尔数组，用于标记每个位置是否已经被访问过
// st[i][j]为true表示位置(i, j)已经被访问过，初始化为false
bool st[N][N];

// 定义一个数组dx，用于表示在x方向上的偏移量
// 分别对应向上、向右、向下、向左四个方向的移动
int dx[] = { -1, 0, 1, 0 };
// 定义一个数组dy，用于表示在y方向上的偏移量
// 分别对应向上、向右、向下、向左四个方向的移动
int dy[] = { 0, 1, 0, -1 };

// 深度优先搜索函数，用于遍历从给定起始位置(x, y)开始能够安全到达的所有位置
// 参数x和y分别表示当前位置的行和列坐标
void dfs(int x, int y)
{
    // 遍历四个方向
    for (int i = 0; i < 4; i++)
    {
        // 根据当前方向的偏移量计算出下一个位置的行坐标a和列坐标b
        int a = x + dx[i], b = y + dy[i];

        // 判断下一个位置是否越界，如果越界则跳过本次循环，继续尝试其他方向
        if (a < 0 || a >= n || b < 0 || b >= m) continue;

        // 判断下一个位置是否为不安全的砖块（'#'），如果是则跳过本次循环，继续尝试其他方向
        if (g[a][b]!= '.')  continue;

        // 判断下一个位置是否已经被访问过，如果已经被访问过则跳过本次循环，继续尝试其他方向
        if (st[a][b]) continue;

        // 将下一个位置标记为已访问
        st[a][b] = true;

        // 能够安全到达的砖块个数加1
        res++;

        // 从新的已访问的安全位置继续进行深度优先搜索，递归地探索其相邻的安全位置
        dfs(a, b);
    }
}

int main()
{
    // 从标准输入读取小路的宽度m和长度n
    cin >> m >> n;

    // 循环读取每一行的字符，填充表示小路瓷砖情况的字符矩阵g
    for (int i = 0; i < n; i++)
    {
        cin >> g[i];
    }

    // 遍历整个字符矩阵，寻找起始位置'@'
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            // 当找到起始位置'@'时
            if (g[i][j] == '@')
            {
                // 将起始位置标记为已访问
                st[i][j] = true;

                // 从起始位置开始进行深度优先搜索
                dfs(i, j);
            }
        }
    }

    // 这里多了一次res的自增操作，应该是多余的，可根据实际逻辑需求判断是否删除
    // 目前代码逻辑来看，在dfs函数内部每次进入新的有效位置已经对res进行了自增操作，这里不需要再次自增
    res++;

    // 将能够安全走过的最多砖块个数输出到标准输出
    cout << res << endl;

    // 返回0，表示程序正常结束
    return 0;
}
