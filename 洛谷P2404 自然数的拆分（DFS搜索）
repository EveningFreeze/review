//1.输入一个数s
//2.对这个数，进行1到s-1的拆分
//3.将拆分出的数放到数组a中，记录，当前a中存放了多少个数
//4.更新我们的s，直到我们完成一次拆分
#include<iostream> 
#include<algorithm>
#include<cstring> 

using namespace std; 

const int N = 10; // 定义一个常量N，表示数组a的最大长度，这里假设最多拆分成10个数
int a[N]; // 定义一个全局数组a，用于存储拆分过程中的中间结果

// 定义一个深度优先搜索（DFS）函数，用于递归地寻找所有可能的拆分方式
void dfs(int s, int step) 
{
	if (s == 0) // 如果s为0，说明当前的拆分已经完成
	{ 
		for (int i = 0; i < step - 1; i++) // 遍历数组a，打印出除了最后一个数之外的所有数
		{ 
			cout << a[i] << "+"; // 打印当前数，并在后面加上"+"符号
		}
		cout << a[step - 1] << endl; // 打印最后一个数，并换行，表示一个拆分序列的结束
	}
	for (int i = 1; i <= s; i++) // 从1开始，遍历到s（当前剩余需要拆分的数）
	{ 
		if (i < a[step - 1]) continue; // 如果当前考虑的数i小于上一个数，则跳过，以保证序列中数字的递增顺序
		a[step] = i; // 将当前考虑的数i放入数组a的下一个位置
		dfs(s - i, step + 1); // 递归调用dfs函数，继续拆分剩余的数s-i
	}
}

int main()
{
	int n; // 定义一个变量n，用于存储待拆分的自然数
	cin >> n; // 从标准输入读取待拆分的自然数n
	for (int i = 1; i <= n / 2; i++)// 从1开始，遍历到n/2，因为大于n/2的数会导致拆分后的序列不满足题目要求
	{ 
		a[0] = i; // 将第一个数i放入数组a的第一个位置
		dfs(n - i, 1); // 调用dfs函数，开始拆分n-i
	}
	return 0; // 程序正常结束
}
