#include<iostream>
using namespace std;

// 定义一个常量N，用于限制数组的大小，这里假设最多处理21个元素的情况
const int N = 21;

// 全局变量n，表示总数，即从多少个元素中进行选择
int n;
// 全局变量r，表示要选取的元素个数
int r;

// 定义一个整型数组arr，用于存储每次选取出来的元素序列
int arr[N];

// 深度优先搜索函数，用于生成从n个元素中选取r个元素的所有组合情况并输出
// 参数x表示当前正在选取的第几个元素（从1开始计数）
// 参数start表示下一次选取元素时的起始下标（用于避免重复选取已经选过的元素）
void dfs(int x, int start)
{
    // 如果当前已经选取的元素个数x大于要选取的元素个数r，说明已经完成了一次从n个元素中选取r个元素的组合
    if (x > r)
    {
        // 遍历数组arr，输出本次选取出来的r个元素，每个元素占3个字符宽度以便输出格式更整齐
        for (int i = 1; i <= r; i++)
        {
            printf("%3d", arr[i]);
        }
        // 输出换行符，使每次选取出来的元素组合在输出时换行显示，更加清晰
        printf("\n");

        // 完成本次组合的输出后，返回上一层递归调用
        return;
    }

    // 从start开始到n，遍历每个元素，尝试将其选入本次要选取的r个元素组合中
    for (int i = start; i <= n; i++)
    {
        // 将当前元素i放入数组arr中，作为本次选取的第x个元素
        arr[x] = i;
        // 递归调用dfs函数，继续选取下一个元素（即第x + 1个元素），下一次选取元素的起始下标为i + 1
        dfs(x + 1, i + 1);
        // 回溯操作：将数组arr中当前位置x的元素清空，以便下一次循环尝试选取其他元素放入该位置
        arr[x] = 0;
    }
}

int main()
{
    // 从标准输入读取两个整数，分别赋值给n和r
    // n表示总数，即从多少个元素中进行选择
    // r表示要选取的元素个数
    cin >> n >> r;

    // 调用深度优先搜索函数dfs，从第一个元素（即x = 1，start = 1）开始生成从n个元素中选取r个元素的所有组合情况
    dfs(1, 1);

    // 返回0，表示程序正常结束
    return 0;
}
