#include<iostream>
using namespace std;

// 定义一个常量N，表示数组的最大长度，这里假设最多处理10个元素的情况
const int N = 10;

// 全局变量n，用于存储输入的整数，代表要进行排列组合的元素个数
int n;

// 定义一个布尔类型的数组st，用于标记数组arr中的每个元素是否已经被使用过，初始值都为false
bool st[N];

// 定义一个整型数组arr，用于存储排列组合过程中的元素序列
int arr[N];

// 深度优先搜索函数，用于生成从1到n的全排列并输出
// 参数x表示当前正在处理的排列位置
void dfs(int x)
{
    // 如果当前处理的排列位置x大于要排列组合的元素个数n，说明已经生成了一个完整的排列
    if (x > n)
    {
        // 遍历数组arr，输出当前生成的完整排列
        for (int i = 1; i <= n; i++)
        {
            printf("%d", arr[i]);
        }
        // 输出换行符，使每个排列在输出时换行显示，更加清晰
        printf("\n");

        // 完成当前排列的输出后，返回上一层递归调用
        return;
    }

    // 从1到n遍历每个元素，尝试将其放入当前排列位置x
    for (int i = 1; i <= n; i++)
    {
        // 如果元素i还没有被使用过（即st[i]为false）
        if (!st[i])
        {
            // 将元素i标记为已使用
            st[i] = true;
            // 将元素i放入当前排列位置x对应的数组arr中
            arr[x] = i;
            // 递归调用dfs函数，继续处理下一个排列位置，即x + 1
            dfs(x + 1);
            // 回溯操作：将元素i标记为未使用，以便后续其他排列组合可以再次使用该元素
            st[i] = false;
            // 将当前排列位置x对应的数组arr中的元素清空，以便下一次尝试放入其他元素
            arr[x] = 0;
        }
    }
}

int main()
{
    // 从标准输入读取一个整数n，该整数表示要进行排列组合的元素个数
    cin >> n;

    // 调用深度优先搜索函数dfs，从第一个排列位置（即x = 1）开始生成全排列
    dfs(1);

    // 返回0，表示程序正常结束
    return 0;
}
