#include <bits/stdc++.h>
using namespace std;

// 定义全局变量，用于表示迷宫的行数
int n;
// 定义全局变量，用于表示迷宫的列数
int m;
// 定义全局变量，用于表示迷宫中的障碍数量
int t;
// 定义起点的横坐标
int sx;
// 定义起点的纵坐标
int sy;
// 定义终点的横坐标
int ex;
// 定义终点的纵坐标
int ey;

// 定义一个二维数组，用于模拟迷宫的布局，这里暂时设定为6x6大小，可根据实际情况调整
int arr[6][6];
// 定义一个二维布尔数组，用于标记每个位置是否已经被访问过
bool st[6][6];

// 定义一个数组，用于表示在横坐标方向上的移动偏移量，分别对应右（1）、左（-1）、不动（0）、不动（0）
int dx[5] = { 0, 1, -1, 0, 0 };
// 定义一个数组，用于表示在纵坐标方向上的移动偏移量，分别对应不动（0）、不动（0）、不动（0）、下（1）、上（-1）
int dy[5] = { 0, 0, 0, 1, -1 };

// 定义一个变量，用于记录从起点到终点的路径数量
int cnt;

// 深度优先搜索函数，用于在迷宫中寻找从起点到终点的路径
// 参数x和y表示当前搜索的位置坐标
void dfs(int x, int y) {
    // 如果当前搜索到的位置就是终点位置
    if (x == ex && y == ey) {
        // 路径数量加1，表示找到了一条从起点到终点的路径
        cnt++;
        // 找到一条路径后，直接返回，继续探索其他可能的路径
        return;
    }

    // 遍历四个方向（上、下、左、右）
    for (int i = 1; i <= 4; i++) {
        // 计算在当前方向上移动后的新位置的横坐标
        int a = x + dx[i];
        // 计算在当前方向上移动后的新位置的纵坐标
        int b = y + dy[i];

        // 判断新位置是否在迷宫范围内（横坐标和纵坐标都要满足条件）
        // 并且该位置没有被访问过（st[a][b]为false表示未访问）
        if (a >= 1 && a <= n && b >= 1 && b <= m &&!st[a][b]) {
            // 将新位置标记为已访问，避免重复访问
            st[a][b] = true;
            // 从新位置继续进行深度优先搜索，递归调用dfs函数
            dfs(a, b);
            // 回溯操作，将新位置标记为未访问，以便在其他路径搜索时该位置还能被访问到
            st[a][b] = false;
        }
    }
}

// 主函数，程序的入口点
signed main() {
    // 从标准输入读取迷宫的行数、列数和障碍数量
    cin >> n >> m >> t;
    // 从标准输入读取起点的横坐标和纵坐标
    cin >> sx >> sy >> ex >> ey;

    // 循环读取每个障碍的位置坐标，并在st数组中将对应位置标记为已访问（表示不可通过）
    for (int i = 1; i <= t; i++) {
        int x, y;
        cin >> x >> y;
        st[x][y] = true;
    }

    // 将起点位置标记为已访问，因为搜索从起点开始
    st[sx][sy] = true;

    // 从起点位置开始进行深度优先搜索
    dfs(sx, sy);

    // 输出从起点到终点的路径数量
    cout << cnt << endl;

    return 0;
}
