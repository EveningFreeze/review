#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

// n表示棋盘的大小（即皇后的数量），因为题目限定N <= 10，这里定义数组大小为15足够使用
int n, sum, flag;

// vis数组用于标记某一列是否已经放置了皇后，vis[i]为1表示第i列已放置，为0表示未放置
int vis[15];

// pic数组用于记录第k行皇后放置在第几列，pic[k]的值表示第k行皇后所在列的编号
int pic[15];

// ans数组用于存储不同棋盘大小n对应的皇后合法放置方案数量，ans[i]表示n为i时的方案数
int ans[15];

// dfs函数实现深度优先搜索来放置皇后，参数k表示当前正在放置第k个皇后（从1开始计数）
void dfs(int k)
{
    // 如果已经成功放置了n个皇后（即已经处理到了第n + 1行，因为行是从1开始计数的），说明找到了一种合法的放置方案
    if (k == n + 1) 
    {
        sum++;  // 合法方案数加1
        return;
    }

    // 尝试在第k行的每一列放置皇后
    for (int i = 1; i <= n; i++)
    {
        // 如果第i列还没有放置皇后
        if (!vis[i])
        {
            pic[k] = i;  // 将第k行的皇后放置在第i列

            flag = 1;  // 先假设当前放置位置是合法的，设置标志为1
            // 检查当前放置的皇后（第k行，第i列）与之前已经放置的皇后（第j行，pic[j]列）是否在同一条斜线上
            for (int j = 1; j < k; j++)
            {
                // 通过判断行列差值的绝对值是否相等来确定是否在同一条斜线上
                // abs(pic[k] - pic[j])表示列的差值的绝对值，abs(k - j)表示行的差值的绝对值
                if (abs(pic[k] - pic[j]) == abs(k - j))
                {
                    flag = 0;  // 如果在同一条斜线上，说明当前放置不合法，将标志设为0
                    break;  // 无需再检查与其他之前放置皇后的情况，直接跳出循环
                }
            }

            // 如果当前放置位置合法（即不在同一条斜线上且该列未被占用）
            if (flag)
            {
                vis[i] = 1;  // 标记第i列已被占用
                dfs(k + 1);  // 继续放置下一行（第k + 1行）的皇后
                vis[i] = 0;  // 回溯，将第i列的占用标记清除，以便后续其他放置情况可以使用该列
            }
        }
    }
}

int main() {
    // 预先计算从棋盘大小为1到10时，皇后的合法放置方案数量
    for (int i = 1; i <= 10; i++) 
    {
        n = i;  // 设置当前棋盘大小为i
        sum = 0;  // 初始化合法放置方案数量为0
        // 初始化vis数组，将所有列标记为未放置皇后（值为0）
        memset(vis, 0, sizeof(vis));
        // 初始化pic数组，默认所有行皇后放置列数为0（表示还未放置）
        memset(pic, 0, sizeof(pic));
        dfs(1);  // 从第1行开始放置皇后，调用深度优先搜索函数
        ans[i] = sum;  // 将计算得到的合法放置方案数量保存到ans数组对应位置
    }

    // 循环读取输入的棋盘大小n，只要n不为0就继续处理
    while (cin >> n && n) 
    {
        printf("%d\n", ans[n]);  // 输出对应棋盘大小n的皇后合法放置方案数量
    }

    return 0;
}
